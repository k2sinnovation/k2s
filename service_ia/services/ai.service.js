const axios = require('axios');
const contextBuilder = require('./context-builder.service');

class AIService {
  
  /**
   * üîç Analyser un message (avec historique optionnel)
   */
  async analyzeMessage(message, user, conversationHistory = []) {
    const settings = user.aiSettings;
    const apiKey = process.env.OPENAI_API_KEY;
    
    if (!apiKey) {
      throw new Error('Cl√© API OpenAI manquante');
    }

    console.log(`[AI:${user._id}] ü§ñ Analyse message de "${message.from}"...`);

    // Charger contexte Drive
    const accessToken = user.emailConfig?.accessToken;
    let driveContext = '';
    
    if (accessToken) {
      try {
        driveContext = await contextBuilder.buildContextFromDrive(
          accessToken, 
          user._id.toString(),
          { includeAppointments: false }
        );
        console.log(`[AI:${user._id}] ‚úÖ Contexte Drive charg√© (${driveContext.length} caract√®res)`);
      } catch (driveError) {
        console.warn(`[AI:${user._id}] ‚ö†Ô∏è Impossible de charger Drive:`, driveError.message);
        driveContext = contextBuilder._buildMinimalContext();
      }
    } else {
      console.warn(`[AI:${user._id}] ‚ö†Ô∏è Pas de token Gmail, contexte minimal`);
      driveContext = contextBuilder._buildMinimalContext();
    }

    // Construire le prompt d'analyse
    const analysisPrompt = this._buildAnalysisSystemPrompt(driveContext);
    const userPrompt = this._buildAnalysisUserPrompt(message, conversationHistory);

    try {
      const response = await axios.post(
        'https://api.openai.com/v1/chat/completions',
        {
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: analysisPrompt },
            { role: 'user', content: userPrompt }
          ],
          temperature: 0.3,
          max_tokens: 200,
          response_format: { type: "json_object" } // ‚úÖ FORCER JSON
        },
        {
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          timeout: 30000
        }
      );

      const content = response.data.choices[0].message.content;
      console.log(`[AI:${user._id}] üìù R√©ponse brute OpenAI:`, content.substring(0, 200));

      // Parser la r√©ponse JSON
      let analysis;
      try {
        analysis = JSON.parse(content);
      } catch (parseError) {
        console.error(`[AI:${user._id}] ‚ùå Erreur parsing JSON:`, parseError.message);
        console.error('Contenu re√ßu:', content);
        
        // Fallback : marquer comme non pertinent
        analysis = {
          is_relevant: false,
          confidence: 0.1,
          intent: 'unknown',
          reason: 'Erreur de parsing de la r√©ponse IA'
        };
      }

      // ‚úÖ NORMALISER LES CL√âS (snake_case vers camelCase si n√©cessaire)
      const normalizedAnalysis = {
        is_relevant: analysis.is_relevant ?? analysis.isRelevant ?? false,
        confidence: analysis.confidence ?? 0.5,
        intent: analysis.intent ?? 'unknown',
        reason: analysis.reason ?? analysis.details ?? 'Non sp√©cifi√©',
        details: analysis.details ?? {}
      };

      console.log(`[AI:${user._id}] ‚úÖ Analyse: ${normalizedAnalysis.intent} (${(normalizedAnalysis.confidence * 100).toFixed(0)}%) - Pertinent: ${normalizedAnalysis.is_relevant}`);

      return normalizedAnalysis;

    } catch (error) {
      console.error(`[AI:${user._id}] ‚ùå Erreur analyse:`, error.message);
      if (error.response) {
        console.error('D√©tails API:', error.response.data);
      }
      
      // Retourner une analyse par d√©faut en cas d'erreur
      return {
        is_relevant: false,
        confidence: 0.0,
        intent: 'error',
        reason: `Erreur IA: ${error.message}`
      };
    }
  }

  /**
   * ü§ñ G√©n√©rer une r√©ponse (avec historique conversation)
   */
  async generateResponse(message, analysis, user, conversationHistory = []) {
    const settings = user.aiSettings;
    const apiKey = process.env.OPENAI_API_KEY;
    
    if (!apiKey) {
      throw new Error('Cl√© API OpenAI manquante');
    }

    console.log(`[AI:${user._id}] üí¨ G√©n√©ration r√©ponse pour intent="${analysis.intent}"...`);

    // Si non pertinent, r√©ponse standard
    if (!analysis.is_relevant) {
      return this._generateOutOfScopeResponse(settings, user);
    }

    // Charger contexte Drive
    const accessToken = user.emailConfig?.accessToken;
    let driveContext = '';
    
    if (accessToken) {
      try {
        driveContext = await contextBuilder.buildContextFromDrive(
          accessToken, 
          user._id.toString(),
          { includeAppointments: true }
        );
        console.log(`[AI:${user._id}] ‚úÖ Contexte Drive charg√© (${driveContext.length} caract√®res)`);
      } catch (driveError) {
        console.warn(`[AI:${user._id}] ‚ö†Ô∏è Impossible de charger Drive:`, driveError.message);
        driveContext = contextBuilder._buildMinimalContext();
      }
    } else {
      console.warn(`[AI:${user._id}] ‚ö†Ô∏è Pas de token Gmail, contexte minimal`);
      driveContext = contextBuilder._buildMinimalContext();
    }

    // Construire le prompt de r√©ponse
    const systemPrompt = this._buildResponseSystemPrompt(driveContext, settings);
    const userPrompt = this._buildResponseUserPrompt(message, analysis, conversationHistory);

    try {
      const response = await axios.post(
        'https://api.openai.com/v1/chat/completions',
        {
          model: settings.aiModel || 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
          temperature: settings.temperature || 0.7,
          max_tokens: settings.maxTokens || 500
        },
        {
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          timeout: 30000
        }
      );

      const generatedResponse = response.data.choices[0].message.content.trim();
      
      console.log(`[AI:${user._id}] ‚úÖ R√©ponse g√©n√©r√©e (${generatedResponse.length} caract√®res)`);

      return generatedResponse;

    } catch (error) {
      console.error(`[AI:${user._id}] ‚ùå Erreur g√©n√©ration:`, error.message);
      if (error.response) {
        console.error('D√©tails API:', error.response.data);
      }
      
      // R√©ponse de secours
      return `Bonjour,\n\nMerci pour votre message. Nous avons bien re√ßu votre demande et nous vous r√©pondrons dans les plus brefs d√©lais.\n\nCordialement,\n${settings.salonName || user.businessName}`;
    }
  }

  /**
   * üìù Construire le prompt syst√®me pour l'ANALYSE
   */
  _buildAnalysisSystemPrompt(driveContext) {
    return `${driveContext}

---

Tu es un expert en analyse de messages clients pour un salon/commerce.

**T√ÇCHE** : Analyse le message suivant et d√©termine s'il est pertinent pour l'entreprise.

**CRIT√àRES DE PERTINENCE** :
- ‚úÖ Pertinent : demande de rendez-vous, question sur prestations, horaires, tarifs, annulation/modification RDV
- ‚ùå Non pertinent : spam, publicit√©, newsletter externe, notification automatique (TikTok, LinkedIn, etc.)

**R√âPONDS UNIQUEMENT EN JSON VALIDE** avec cette structure exacte :
{
  "is_relevant": true/false,
  "confidence": 0.0 √† 1.0,
  "intent": "prise_rdv" | "question_info" | "annulation" | "modification" | "reclamation" | "spam" | "autre",
  "reason": "Explication courte de ta d√©cision",
  "details": {
    "date_souhaitee": "si mentionn√©e",
    "prestation_souhaitee": "si mentionn√©e"
  }
}`;
  }

  /**
   * üìù Construire le prompt utilisateur pour l'ANALYSE
   */
  _buildAnalysisUserPrompt(message, conversationHistory) {
    let prompt = '';

    if (conversationHistory.length > 0) {
      prompt += '**HISTORIQUE CONVERSATION** :\n';
      conversationHistory.slice(-3).forEach(msg => {
        prompt += `- De: ${msg.from}\n  Message: ${msg.body.substring(0, 100)}...\n\n`;
      });
    }

    prompt += `**MESSAGE √Ä ANALYSER** :
De: ${message.from}
Sujet: ${message.subject || '(sans objet)'}

Corps:
${message.body}

---
Analyse ce message et r√©ponds en JSON.`;

    return prompt;
  }

  /**
   * üìù Construire le prompt syst√®me pour la R√âPONSE
   */
  _buildResponseSystemPrompt(driveContext, settings) {
    const tone = settings.tone || 'professionnel';
    
    return `${driveContext}

---

Tu es ${settings.role || 'un assistant virtuel'} pour ${settings.salonName || 'cette entreprise'}.

**INSTRUCTIONS** :
${settings.instructions || 'Sois professionnel et courtois.'}

**TON** : ${tone}

**R√àGLES** :
1. R√©ponds en fran√ßais naturel et fluide
2. Sois concis (3-5 phrases maximum)
3. Utilise les informations du contexte Drive pour personnaliser
4. Propose des cr√©neaux concrets si pertinent
5. Termine toujours par une formule de politesse
6. N'invente JAMAIS d'informations non pr√©sentes dans le contexte

**FORMAT DE R√âPONSE** : Texte brut uniquement (pas de JSON, pas de markdown).`;
  }

  /**
   * üìù Construire le prompt utilisateur pour la R√âPONSE
   */
  _buildResponseUserPrompt(message, analysis, conversationHistory) {
    let prompt = '';

    if (conversationHistory.length > 0) {
      prompt += '**HISTORIQUE CONVERSATION** :\n';
      conversationHistory.slice(-3).forEach(msg => {
        prompt += `- ${msg.from}: ${msg.body.substring(0, 80)}...\n`;
      });
      prompt += '\n';
    }

    prompt += `**MESSAGE CLIENT** :
De: ${message.from}
Sujet: ${message.subject || '(sans objet)'}

${message.body}

---

**ANALYSE D√âTECT√âE** :
- Intention: ${analysis.intent}
- Confiance: ${(analysis.confidence * 100).toFixed(0)}%
${analysis.details?.date_souhaitee ? `- Date souhait√©e: ${analysis.details.date_souhaitee}` : ''}
${analysis.details?.prestation_souhaitee ? `- Prestation: ${analysis.details.prestation_souhaitee}` : ''}

G√©n√®re une r√©ponse professionnelle et personnalis√©e.`;

    return prompt;
  }

  /**
   * üìß R√©ponse standard pour messages hors scope
   */
  _generateOutOfScopeResponse(settings, user) {
    return `Bonjour,

Merci pour votre message.

Je suis un assistant automatique d√©di√© uniquement aux demandes concernant ${settings.salonName || user.businessName} (rendez-vous, prestations, horaires).

Pour toute autre demande, contactez :
üìß ${settings.ownerEmail || user.email}
üìû ${settings.ownerPhone || 'Nous contacter'}

Cordialement,
Assistant ${settings.salonName || user.businessName}`;
  }
}

module.exports = new AIService();
